<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Asteroids — Single Player (One-File)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f12; color:#e6edf3; font-family:system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    .hud { position:fixed; top:10px; left:10px; background:rgba(0,0,0,.5); padding:10px 12px; border-radius:8px; font-size:14px; max-width:520px; }
    .hud .help { margin-top:6px; opacity:.85; }
    #game { display:block; margin:0 auto; background:#0d1117; border:1px solid #1f2630; }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Mode</b>: Single Player</div>
    <div><b>Score</b>: <span id="score">0</span></div>
    <div class="help">WASD / Arrows to move • Aim with mouse • Auto-fire • Crash = 7s respawn • Press R to restart</div>
  </div>
  <canvas id="game" width="960" height="600"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    const $score = document.getElementById("score");
    const now = () => performance.now() / 1000;

    // Tunables
    const SHIP_R = 12;
    const ROCK_MIN = 18, ROCK_MAX = 38;
    const ROCK_SPEED = 40;
    const BULLET_SPEED = 360;
    const SHOT_PERIOD = 0.14;
    const THRUST = 180, STRAFE = 0.6, BRAKE = 0.985, FRICTION = 0.99, RESPAWN_SECS = 7;

    // State
    const state = {
      score: 0,
      player: { x: W/2, y: H/2, rot: 0, vx: 0, vy: 0, alive: true, respawnAt: 0, color: "#9ecbff", bullets: [], lastShot: 0 },
      rocks: [], keys: {}, mouse: { x: W/2, y: H/2 }, gameOver: false
    };

    function wrap(v, max){ return v<0? v+max : v>max? v-max : v; }
    function rand(a,b){ return Math.random()*(b-a)+a; }

    function spawnRocks(n=8){
      state.rocks = [];
      for (let i=0;i<n;i++){
        state.rocks.push({ x: rand(0,W), y: rand(0,H), vx: rand(-ROCK_SPEED, ROCK_SPEED), vy: rand(-ROCK_SPEED, ROCK_SPEED), r: rand(ROCK_MIN, ROCK_MAX) });
      }
    }

    function resetGame(){
      state.score = 0; $score.textContent = "0";
      const p = state.player;
      p.x = W/2; p.y = H/2; p.vx = p.vy = 0; p.alive = true; p.respawnAt = 0; p.bullets = []; p.lastShot = 0;
      state.gameOver = false;
      spawnRocks(8);
    }

    // Drawing
    function drawShip(p, a=1){
      ctx.save(); ctx.globalAlpha = a; ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.strokeStyle = p.color; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(14,0); ctx.lineTo(-10,-8); ctx.lineTo(-6,0); ctx.lineTo(-10,8); ctx.closePath(); ctx.stroke();
      ctx.restore(); ctx.globalAlpha = 1;
    }
    function drawBullet(b){ ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(b.x,b.y,2,0,Math.PI*2); ctx.fill(); }
    function drawRock(r){ ctx.strokeStyle="#aaa"; ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.stroke(); }

    // Update
    function updatePlayer(dt){
      const p = state.player; if (!p.alive) return;
      p.rot = Math.atan2(state.mouse.y - p.y, state.mouse.x - p.x);
      const fwdX = Math.cos(p.rot), fwdY = Math.sin(p.rot);
      const rightX = Math.cos(p.rot + Math.PI/2), rightY = Math.sin(p.rot + Math.PI/2);
      if (state.keys["w"] || state.keys["arrowup"]) { p.vx += fwdX * THRUST * dt; p.vy += fwdY * THRUST * dt; }
      if (state.keys["s"] || state.keys["arrowdown"]) { p.vx *= BRAKE; p.vy *= BRAKE; }
      if (state.keys["a"] || state.keys["arrowleft"]) { p.vx += rightX * -THRUST * STRAFE * dt; p.vy += rightY * -THRUST * STRAFE * dt; }
      if (state.keys["d"] || state.keys["arrowright"]) { p.vx += rightX * THRUST * STRAFE * dt; p.vy += rightY * THRUST * STRAFE * dt; }
      p.vx *= FRICTION; p.vy *= FRICTION;
      p.x = wrap(p.x + p.vx * dt, W); p.y = wrap(p.y + p.vy * dt, H);
      p.lastShot += dt;
      if (p.lastShot > SHOT_PERIOD) {
        p.lastShot = 0;
        p.bullets.push({ x: p.x + Math.cos(p.rot)*14, y: p.y + Math.sin(p.rot)*14, vx: Math.cos(p.rot)*BULLET_SPEED, vy: Math.sin(p.rot)*BULLET_SPEED, t: 0 });
      }
    }
    function updateBullets(dt){
      const p = state.player;
      p.bullets = p.bullets.filter(b => { b.x = wrap(b.x + b.vx*dt, W); b.y = wrap(b.y + b.vy*dt, H); b.t += dt; return b.t < 2.5; });
    }
    function updateRocks(dt){ for (const r of state.rocks){ r.x = wrap(r.x + r.vx*dt, W); r.y = wrap(r.y + r.vy*dt, H); } }
    function collisions(){
      const p = state.player;
      if (p.alive) {
        for (const b of p.bullets) {
          for (const r of state.rocks) {
            const dx = b.x - r.x, dy = b.y - r.y;
            if (dx*dx + dy*dy < r.r*r.r) {
              b.t = 999; r.r *= 0.66; state.score += 10; $score.textContent = String(state.score);
              if (r.r < 12) { r.x = rand(0,W); r.y = rand(0,H); r.r = rand(18,38); r.vx = rand(-40,40); r.vy = rand(-40,40); }
            }
          }
        }
        for (const r of state.rocks) {
          const dx = p.x - r.x, dy = p.y - r.y, rr = r.r + SHIP_R;
          if (dx*dx + dy*dy < rr*rr) { p.alive = false; p.respawnAt = now() + 7; p.bullets = []; break; }
        }
      } else if (now() >= p.respawnAt && !state.gameOver) {
        p.alive = true; p.x = rand(100, W-100); p.y = rand(100, H-100); p.vx = p.vy = 0; p.bullets = [];
      }
    }

    function loop(ts){
      if (!loop.last) loop.last = ts;
      const dt = Math.min(0.05, (ts - loop.last) / 1000); loop.last = ts;

      if (!state.gameOver) { updatePlayer(dt); updateBullets(dt); updateRocks(dt); collisions(); }

      ctx.clearRect(0,0,W,H);
      for (const r of state.rocks) drawRock(r);
      const p = state.player;
      if (p.alive) { drawShip(p,1); for (const b of p.bullets) drawBullet(b); }
      else { const secLeft = Math.max(0, Math.ceil(p.respawnAt - now())); drawShip(p,0.25); ctx.fillStyle="#9ecbff"; ctx.font="12px system-ui"; ctx.fillText(`respawn ${secLeft}s`, p.x+14, p.y-14); }

      requestAnimationFrame(loop);
    }

    function setupInput(){
      addEventListener("keydown", e => { const k = e.key.toLowerCase(); state.keys[k] = true; if (k === "r") resetGame(); });
      addEventListener("keyup", e => { const k = e.key.toLowerCase(); state.keys[k] = false; });
      canvas.addEventListener("mousemove", e => { const rect = canvas.getBoundingClientRect(); state.mouse.x = e.clientX - rect.left; state.mouse.y = e.clientY - rect.top; });
    }

    function start(){ setupInput(); resetGame(); requestAnimationFrame(loop); }
    start();
  </script>
</body>
</html>
